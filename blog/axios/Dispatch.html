<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>七、请求分发 &amp;&amp; 适配器 | Secret</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/blog/assets/css/0.styles.d244ddc1.css" as="style"><link rel="preload" href="/blog/assets/js/app.d0f691b7.js" as="script"><link rel="preload" href="/blog/assets/js/2.193d832c.js" as="script"><link rel="preload" href="/blog/assets/js/21.e05837f8.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.fe6cbfee.js"><link rel="prefetch" href="/blog/assets/js/11.139d241f.js"><link rel="prefetch" href="/blog/assets/js/12.222ab8bb.js"><link rel="prefetch" href="/blog/assets/js/13.f9d0cf37.js"><link rel="prefetch" href="/blog/assets/js/14.faf6eeb3.js"><link rel="prefetch" href="/blog/assets/js/15.ad5b9b70.js"><link rel="prefetch" href="/blog/assets/js/16.01445cb0.js"><link rel="prefetch" href="/blog/assets/js/17.329331a9.js"><link rel="prefetch" href="/blog/assets/js/18.41a5e146.js"><link rel="prefetch" href="/blog/assets/js/19.f83fcfe6.js"><link rel="prefetch" href="/blog/assets/js/20.5f11b046.js"><link rel="prefetch" href="/blog/assets/js/22.2ecfae4a.js"><link rel="prefetch" href="/blog/assets/js/23.f78999b8.js"><link rel="prefetch" href="/blog/assets/js/24.42ba54a6.js"><link rel="prefetch" href="/blog/assets/js/25.4cb179fd.js"><link rel="prefetch" href="/blog/assets/js/26.849a1d16.js"><link rel="prefetch" href="/blog/assets/js/27.2e954321.js"><link rel="prefetch" href="/blog/assets/js/28.2c3e24f2.js"><link rel="prefetch" href="/blog/assets/js/29.614e50fd.js"><link rel="prefetch" href="/blog/assets/js/3.9dfa9226.js"><link rel="prefetch" href="/blog/assets/js/30.e7cfa59a.js"><link rel="prefetch" href="/blog/assets/js/31.0739bf20.js"><link rel="prefetch" href="/blog/assets/js/32.ccca9e29.js"><link rel="prefetch" href="/blog/assets/js/33.8781f9fe.js"><link rel="prefetch" href="/blog/assets/js/34.2d587b29.js"><link rel="prefetch" href="/blog/assets/js/35.83d5cca7.js"><link rel="prefetch" href="/blog/assets/js/36.7253c9c7.js"><link rel="prefetch" href="/blog/assets/js/37.486536cb.js"><link rel="prefetch" href="/blog/assets/js/38.1f2fb8a7.js"><link rel="prefetch" href="/blog/assets/js/39.43d80e35.js"><link rel="prefetch" href="/blog/assets/js/4.c1635489.js"><link rel="prefetch" href="/blog/assets/js/40.4b2ac2d3.js"><link rel="prefetch" href="/blog/assets/js/41.60a5f16e.js"><link rel="prefetch" href="/blog/assets/js/42.0eaa7a3d.js"><link rel="prefetch" href="/blog/assets/js/43.1275931a.js"><link rel="prefetch" href="/blog/assets/js/44.b9fb6912.js"><link rel="prefetch" href="/blog/assets/js/45.87014400.js"><link rel="prefetch" href="/blog/assets/js/5.5939d75c.js"><link rel="prefetch" href="/blog/assets/js/6.5da43515.js"><link rel="prefetch" href="/blog/assets/js/7.ad1cbc2e.js"><link rel="prefetch" href="/blog/assets/js/8.d47f9bc9.js"><link rel="prefetch" href="/blog/assets/js/9.46020f45.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.d244ddc1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Secret</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/blog/document/swiper.html" class="nav-link">
  技术文档
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/blog/document/swiper.html" class="nav-link">
  技术文档
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>技术文档</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>深入axios</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/axios/tools.html" class="sidebar-link">一、工具类</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/blog/axios/constructor.html" class="sidebar-link">二、axios实例</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/blog/axios/config.html" class="sidebar-link">三、默认配置项</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/blog/axios/mergeConfig.html" class="sidebar-link">四、选项合并</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/blog/axios/Axios.html" class="sidebar-link">五、Axios 核心类</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/blog/axios/Interceptors.html" class="sidebar-link">六、拦截器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/blog/axios/Dispatch.html" class="active sidebar-link">七、请求分发 &amp;&amp; 适配器</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Express</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node.js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>跨域</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>学习轨迹</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>散文随笔</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="七、请求分发-适配器"><a href="#七、请求分发-适配器" class="header-anchor">#</a> 七、请求分发 &amp;&amp; 适配器</h1> <p>在<a href="/Interceptors.html">拦截器</a>一文中提到，我们使用对应的 interceptor.use 的时候，会向 handles 放入对应的处理函数，针对两种拦截器会分别在 chain 的队头和队尾添加这些处理函数，当设置拦截器时，chain 队列会变成这样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  [requestResolve,  requestReject, dispatchRequest, undefined, responseResolve, responseReject]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果没有设置拦截器 chain 队列就是默认值即: [dispatchRequest, undefined]，dispatchRequest 即为调用 axios[method] 时真正的处理函数。然后基于 axios.config 创建promise实例，循环 chain 队列，依次调用这些处理函数。</p> <p>由于 promise 是基于 axios.config 创建的，所以在 promise.then() 里执行的 dispatchRequest 入参应该也是 axios.config。</p> <h3 id="dispatch"><a href="#dispatch" class="header-anchor">#</a> dispatch</h3> <p>文件路径：/lib/core/dispatchRequest.js</p> <p>dispatchRequest 方法的定义在 line 23 - 79，该方法的传参正如我们所想就是 axios.config，返回一个Promise。</p> <p>line 24 - line 41:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  module.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    // Ensure headers exist
    config.headers = config.headers || {};

    // Transform request data
    config.data = transformData(
      config.data,
      config.headers,
      config.transformRequest
    );

    // Flatten headers
    config.headers = utils.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers
    );

    utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );
    ....
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>1、throwIfCancellationRequested(config) 函数用来取消请求的 cancel token。</p> <p>2、确保 config.headers 存在，因为下一步会用到 config.headers</p> <p>3、根据配置项的 config.transformRequest 来转化请求数据。
文档上的该配置项的使用方法为：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  transformRequest: [function (data, headers) {
    // 对 data 进行任意转换处理
    return data;
  }],
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>transformRequest 的传参是一个数组，可以传入多个函数依次调用，返回的 data 为最后一次调用的处理函数的结果。</p> <p>在 axios 里它的实现方式为：</p> <p>文件路径：/lib/core/transformData.js</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  module.exports = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });

    return data;
  };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>通过 util.forEach() 方法遍历 transformData 方法传入的第三个参数fns，在这里fns 指的是 config.transformRequest，然后依次调用每一个fn，得到的结果（data） 传给下一个 fn。最后返回处理完成的 data。</p> <p>4、扁平化 headers。</p> <p>5、删除 config.headers[method] ??? 为啥要删除。</p> <p>line 50 - line 78:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  module.exports = function dispatchRequest(config) {
    ...

    var adapter = config.adapter || defaults.adapter;

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData(
        response.data,
        response.headers,
        config.transformResponse
      );

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason &amp;&amp; reason.response) {
          reason.response.data = transformData(
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }
      return Promise.reject(reason);
    });
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>这一部分主要是选择对应的 adapter(config | defaults.adapter)，执行 then()方法得到 Response，adapter 应该是一个 thenable 的对象。最后同样通过 config.transformResponse 去转化 response data。</p> <h3 id="adaptper"><a href="#adaptper" class="header-anchor">#</a> adaptper</h3> <p>在<a href="config.html">默认配置项</a>一文中，简单介绍了下默认的 adapter 配置：</p> <blockquote><p>该选项决定了 axios 根据何种方式处理 ajax 请求，它是可写的，允许用户自定义处理请求。默认情况下会检查当前环境，如果浏览器环境会引入 ./adapters/xhr 文件处理，如果为 node 环境会引入 ./adapter/http 文件处理。</p></blockquote> <h4 id="adapter-xhr"><a href="#adapter-xhr" class="header-anchor">#</a> adapter(xhr)</h4> <p>文件路径：/lib/adapters/xhr.js</p> <p>由上文明显可以看到，adapter 的传参是 axios.config，config 在 dispatchRequest 函数里已经处理过。adapter 是个thenable 的函数，猜想 adapter 函数应该返回一个 Promise。</p> <p>该路径下的文件是浏览器环境引入的，应该是调用的原生 XMLHttpRequest 对象处理 ajax 请求。</p> <p>line 11 - 20：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  module.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest();
      ...
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>印证了我们的猜想，xhr adapter 返回了一个Promise，同时创建两个变量 requestData 和 requestHeaders，
判断 requestData 是否为 formData，是的话删除content-Type。与此同时还创建了 request 变量，一个XMLHttpRequest 实例。</p> <p>line 23 - 33</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  ...
  if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;
  ...
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>提供基本HTTP验证，如果配置中传入了 auth，会将相应的数据经过 btoa 编码写入到请求头里。然后调用 xhr.open(method, url) 初始化一个请求。第三个参数为 true 代表：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>一个可选的布尔参数，默认为true，表示要不要异步执行操作。如果值为false，send()方法直到收到答复前不会返回。如果true，已完成事务的通知可供事件监听器使用。如果multipart属性为true则这个必须为true，否则将引发异常。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个参数决定了 xhr 对象是否可以调用事件侦听器处理 xhr 不同阶段的数据。</p> <p>line 105 - line 116 主要是设置 xsrfHeaders.</p> <p>line 119 - line 128 给 request 对象挂载请求头。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  ...
  if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' &amp;&amp; key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
  }
  ...
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>line 178, 发送请求。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  request.send(requestData);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>line 36 - line 100, 主要是通过侦听器判断请求的状态进行不同的处理。</p> <p>onreadystatechange readyState 发生改变的回调。下标列出了可能存在的值，需要注意的是为 4 的时候代表数据返回成功。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  0	UNSENT	代理被创建，但尚未调用 open() 方法。
  1	OPENED	open() 方法已经被调用。
  2	HEADERS_RECEIVED	send() 方法已经被调用，并且头部和状态已经可获得。
  3	LOADING	下载中； responseText 属性已经包含部分数据。
  4	DONE	下载操作已完成。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>line 36 - line 65, 数据返回成功，封装返回数据。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>这段代码主要是监听 readyState 的值，如果为 4 的话，封装 response 的并返回，注意接口返回的值也是挂载到 request 对象上的。我们在 Interceptors 一章中举例说明了一下 axios 的返回数据结构，和这边定义的也是一致的，</p> <p>line 68 - line 100，主要是处理 abort，error，timeout 的情况。这边不做深入分析。</p> <h4 id="adapter-http-https"><a href="#adapter-http-https" class="header-anchor">#</a> adapter(http/https)</h4> <p>基于 http / https 的适配器，用于在非浏览器环境下发起请求。说一下核心思路吧。</p> <h4 id="_1、选择处理模块"><a href="#_1、选择处理模块" class="header-anchor">#</a> 1、选择处理模块</h4> <p>axios 选项中定义了一个 transport 属性，允许你重写 axios 内部在非浏览器环境下的请求方式。但是在 axios 文档中并没有写。</p> <p>https.js line 161 - line 172</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var transport;
  var isHttpsProxy = isHttpsRequest &amp;&amp; (proxy ? isHttps.test(proxy.protocol) : true);
  if (config.transport) {
    transport = config.transport;
  } else if (config.maxRedirects === 0) {
    transport = isHttpsProxy ? https : http;
  } else {
    if (config.maxRedirects) {
      options.maxRedirects = config.maxRedirects;
    }
    transport = isHttpsProxy ? httpsFollow : httpFollow;
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>axios 会根据是否是 https 请求选用 https / http模块，同时如果选用了 maxRedirects 将会采用 follow-redirects 模块。</p> <p>follow-redirects 是 http / https 的替代品，用于更好的处理重定向相关的请求。<a href="https://www.npmjs.com/package/follow-redirects">follow-redirects</a></p> <h4 id="_2、处理请求"><a href="#_2、处理请求" class="header-anchor">#</a> 2、处理请求</h4> <p>基于流的方式处理响应。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  var req = transport.request(options, function handleResponse(res) {
  if (req.aborted) return;

  // uncompress the response body transparently if required
  var stream = res;
  switch (res.headers['content-encoding']) {
  /*eslint default-case:0*/
  case 'gzip':
  case 'compress':
  case 'deflate':
    // add the unzipper to the body stream processing pipeline
    stream = (res.statusCode === 204) ? stream : stream.pipe(zlib.createUnzip());

    // remove the content-encoding in order to not confuse downstream operations
    delete res.headers['content-encoding'];
    break;
  }

  // return the last request in case of redirects
  var lastRequest = res.req || req;

  var response = {
    status: res.statusCode,
    statusText: res.statusMessage,
    headers: res.headers,
    config: config,
    request: lastRequest
  };

  if (config.responseType === 'stream') {
    response.data = stream;
    settle(resolve, reject, response);
  } else {
    var responseBuffer = [];
    stream.on('data', function handleStreamData(chunk) {
      responseBuffer.push(chunk);

      // make sure the content length is not over the maxContentLength if specified
      if (config.maxContentLength &gt; -1 &amp;&amp; Buffer.concat(responseBuffer).length &gt; config.maxContentLength) {
        stream.destroy();
        reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
          config, null, lastRequest));
      }
    });

    stream.on('error', function handleStreamError(err) {
      if (req.aborted) return;
      reject(enhanceError(err, config, null, lastRequest));
    });

    stream.on('end', function handleStreamEnd() {
      var responseData = Buffer.concat(responseBuffer);
      if (config.responseType !== 'arraybuffer') {
        responseData = responseData.toString(config.responseEncoding);
      }

      response.data = responseData;
      settle(resolve, reject, response);
    });
  }
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br></div></div><p>通过 http.request(options, func) 回调里拿到 res, res 是基于 stream 的，监听 res 的 data 事件，不断的拿到 chunk 放到 结果数组里。然后监听 end 事件，把结果数组转化一下再 resolve 出去。options 是通过传入的 config 拼装而成。 response 数据结构和 xhr 方式一致。以达到统一的效果。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/blog/axios/Interceptors.html" class="prev">
        六、拦截器
      </a></span> <span class="next"><a href="/blog/blog/express/ex.html">
        一、构造函数
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.d0f691b7.js" defer></script><script src="/blog/assets/js/2.193d832c.js" defer></script><script src="/blog/assets/js/21.e05837f8.js" defer></script>
  </body>
</html>
