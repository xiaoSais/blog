(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{240:function(s,a,n){"use strict";n.r(a);var t=n(17),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"六、关于this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#六、关于this"}},[s._v("#")]),s._v(" 六、关于this")]),s._v(" "),n("p",[s._v("\b今天重温了\b\b《你不知道的JavaScript》一书，\b特别是关于this这\b章\b，受益匪浅\b，特此记录总结一下。")]),s._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" \b总结")]),s._v(" "),n("blockquote",[n("p",[s._v("this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。")])]),s._v(" "),n("p",[s._v("这句话在第一卷81页，也是\b关于this指向的精髓。\b它的意思是要知道this\b指向的谁，要分析函数的调用位置，本质上函数的调用是一个不断堆栈的过程，也就是要分析好函数\b的调用栈。")]),s._v(" "),n("h2",{attrs:{id:"this的四种绑定方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this的四种绑定方式"}},[s._v("#")]),s._v(" \bthis的四种绑定方式")]),s._v(" "),n("h3",{attrs:{id:"默认绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#默认绑定"}},[s._v("#")]),s._v(" 默认绑定")]),s._v(" "),n("p",[s._v("调用函数的时候不加\b任何修饰,此时只能应用默认绑定规则。默认规则下this指向全局变量。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function foo() { \n    console.log(this.a);\n}\nvar a = 2; \nfoo(); // 2\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("调用foo方法的时，不加任何修饰此时this应用默认绑定规则，this.a\b也就是window.a。")]),s._v(" "),n("h3",{attrs:{id:"隐式绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#隐式绑定"}},[s._v("#")]),s._v(" 隐式绑定")]),s._v(" "),n("p",[s._v("调用函数时，要考虑调用位置是否有上下文对象，如果有的话this指向的\b就是该\b上下文对象。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function foo() { \n    console.log(this.a);\n}\nvar obj = { a: 2, foo: foo };\nobj.foo(); // 2\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("foo函数被调用时，调用的位置有obj对象，this\b被绑定在这个obj对象上。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\nfunction foo() { \n    console.log(this.a);\n}\nvar obj2 = { a: 42, foo: foo };\nvar obj1 = { a: 2, obj2: obj2 };\nobj1.obj2.foo(); // 42\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("对象属性引用链中只有最顶层或者说最后一层会影响调用位置，所以在该例子中this只能被绑定在最顶层的obj2对象上。")]),s._v(" "),n("h4",{attrs:{id:"隐式丢失"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#隐式丢失"}},[s._v("#")]),s._v(" 隐式丢失")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('function foo() { \n    console.log(this.a);\n}\nvar obj = { a: 2, foo: foo };\nvar bar = obj.foo; // 函数别名!\nvar a = "oops, global"; // a 是全局对象的属性 \nbar(); // "oops, global" \n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("在这个例子中obj.foo被\b赋值给bar，\bbar\b实际上\b指向的是foo这里调用bar()也就是相当于直接调用了foo()，此时没有任何修饰符修饰，\bthis应用默认绑定规则。对象的复制只是\b复制了一份引用。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('function foo() { \n    console.log(this.a);\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是 foo \n    fn(); // <-- 调用位置!\n}\nvar obj = { a: 2, foo: foo };\nvar a = "oops, global"; // a 是全局对象的属性 \ndoFoo( obj.foo ); // "oops, global"\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[s._v("隐藏的\b引用类型的变量复制，存在于入参的时候，和上一个\b例子道理相同。")]),s._v(" "),n("h3",{attrs:{id:"显示绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#显示绑定"}},[s._v("#")]),s._v(" 显示绑定")]),s._v(" "),n("p",[s._v("通过apply()和call()函数，强制指定this的绑定对象。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function foo() { \n    console.log(this.a);\n}\nvar obj = { a:2 };\nfoo.call( obj ); // 2\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("在这个例子中，如果直接执行foo()，this执行默认绑定规则，this.a也就是等于window\b.a。但是在调用foo()方法时，\b调用了call方法，\b强制改变this的指向，将this指向call中的参数obj，\b此时this.a就是代表了obj.a。")]),s._v(" "),n("h3",{attrs:{id:"new绑定"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new绑定"}},[s._v("#")]),s._v(" \bnew绑定")]),s._v(" "),n("p",[s._v("在使用new函数绑定的时候，this指向创建的对象。在使用new创建对象的时候，发生了以下几件事。")]),s._v(" "),n("ol",[n("li",[s._v("创建(或者说构造)一个全新的对象。")]),s._v(" "),n("li",[s._v("这个新对象会被执行[[原型]]连接。")]),s._v(" "),n("li",[s._v("这个新对象会绑定到函数调用的this。")]),s._v(" "),n("li",[s._v("如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function foo(a) { \n    this.a = a;\n}\nvar bar = new foo(2); \nconsole.log( bar.a ); // 2\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("在这个\b例子中，this指向刚创建的对象bar，所以bar.a 为2。")]),s._v(" "),n("h2",{attrs:{id:"优先级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[s._v("#")]),s._v(" 优先级")]),s._v(" "),n("ol",[n("li",[s._v("由new调用?绑定到新创建的对象。")]),s._v(" "),n("li",[s._v("由call或者apply(或者bind)调用?绑定到指定的对象。")]),s._v(" "),n("li",[s._v("由上下文对象调用?绑定到那个上下文对象。")]),s._v(" "),n("li",[s._v("默认:在严格模式下绑定到undefined，否则绑定到全局对象。")])]),s._v(" "),n("h2",{attrs:{id:"例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[s._v("#")]),s._v(" 例子")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function foo(num) {\n    console.log('foo  ' + num)\n    this.count ++\n}\nfoo.count = 0\nvar i\nfor(i =0; i<10; i++) {\n    if(i > 5) {\n        foo(i)\n    }\n}\n//foo.count 0\n//window.count NAN\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("p",[s._v("\b\n一眼就看出来foo.count并不会变成4，因为在循环内\b调用foo(i)的是window对象，此时foo方法内this指向的是也是window对象，然而\b我还是太年轻，window.count 打印出来为NA\b\bN。"),n("b",[s._v("细思一下是因为window.count并没有初始化值，此时underfined执行++操作符\b就变成了NAN，如果初始化window.count = 0，运行完结果window.count = 4。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function foo() { \n    console.log(this.a);\n}\nvar a = 2; \nfoo(); // 2\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("分析该函数的调用栈，调用foo\b()函数的位置是在window，\b所以this.a应该\b代表的是window.a")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function foo() { \n    var a = 2;\n    this.bar(); \n}\nfunction bar() { \n    console.log(this.a);\n}\nfoo(); // ReferenceError: a is not defined\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("\b这个例子我比较困惑，调用foo()函数的时候，调用位置是在window，所以this.bar()也就是\b调用window.bar()，事实情况下\b\b也是能够调用成功的，this.a报错，\b并且书上这么写：")]),s._v(" "),n("blockquote",[n("p",[s._v("这段代码试图通过 this.bar() 来引用 bar() 函数。这是绝对不可能成功的。编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，你不能使用 this 来引用一 个词法作用域内部的东西。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);